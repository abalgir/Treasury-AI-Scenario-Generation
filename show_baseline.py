#!/usr/bin/env python3
"""
show_baseline.py
Validator for Treasury PoC state and portfolio files.

Purpose:
- Confirm that liquidity metrics from state.json are coherent and Basel-consistent.
- Apply same logic as state_builder.py (clip negative net_outflows, use gross fallback).
- Detect impossible improvements under stress scenarios.
- Extract VaR from state.profile_var for complete baseline reporting.

Reads:
  with_whom/data/state.json
  with_whom/data/portfolio_view.json
  with_whom/data/stressed_state.json  (optional)

Module Overview:
----------------
This script serves as a validation tool within the Treasury AI Proof-of-Concept (PoC), ensuring the integrity
of liquidity metrics generated by state_builder.py. It recomputes key Basel III indicators (LCR, survival days)
from raw cashflows and HQLA in state.json, cross-verifying against stored values. It flags logical inconsistencies
(e.g., stressed LCR > baseline) and extracts market risk metrics like VaR for holistic reporting.

Key Features:
-------------
- Independent recomputation: Mirrors state_builder logic for inflows/outflows over 30-day LCR horizon.
- Conservative fallbacks: Clips negative net outflows to zero; uses gross outflows for LCR if inflows dominate.
- Stress validation: Compares baseline vs. stressed_state.json to detect implausible improvements.
- VaR extraction: Pulls 1-day 99% VaR from profile_var for risk completeness.
- Audit-friendly: Prints detailed metrics, warnings, and audit keys for treasurer review.

Regulatory Alignment:
---------------------
- LCR per Basel III (BCBS 238): HQLA / net outflows >=100%; gross fallback for conservatism.
- Survival days: HQLA / (net outflows / 30) for NSFR-like horizon estimation.
- Ensures no "impossible" stress outcomes, aligning with ECB/SEC scenario testing guidelines.

Dependencies:
-------------
- Python 3.8+: json, datetime, timedelta, pathlib (standard library).
- No external libs; runs in isolation for quick CLI validation.

Usage in Workflow:
------------------
- Post state_builder.py: python show_baseline.py (validates baseline; optional stressed).
- Output: Console summary with metrics/comparisons; no files written.
- Integration: Callable from orchestrator for automated checks; extend to Streamlit for interactive viz.
- CLI: Handles missing files gracefully (warns, exits on criticals).

Error Handling:
---------------
- Missing files: Warn and skip (e.g., no stressed comparison).
- Parse fails: Error print, None return.
- Invalid dates/amounts: Fallbacks (today, zero) to prevent crashes.

Example Output:
---------------
--- BASELINE STATE ---
HQLA total (USD): 1,250,000,000.00
Inflows 30d (USD): 800,000,000.00
Outflows 30d (USD): 600,000,000.00
Raw net_outflows (out-in): -200,000,000.00
[INFO] Inflows exceed outflows → using conservative gross-outflow LCR.
LCR (effective): 2.083333
Survival days (effective): 62.50
...

Author:
-------
FintekMinds TreasuryAI PoC — Baseline Validation Module
Version: 2025-10 (Aligned with state_builder LCR logic)
"""

import json
from datetime import datetime, timedelta
from pathlib import Path

DATA_DIR = Path(__file__).resolve().parent / "data"

# ------------------------- Helpers -------------------------

def load_json(name: str):
    """
    Load and parse JSON file from DATA_DIR.

    Args:
        name: Filename (e.g., 'state.json').

    Returns:
        dict or None: Parsed data or None on missing/parse error.

    Behavior:
        - Checks existence; warns if absent.
        - Catches JSON decode errors; prints and returns None.
        - Used for state, portfolio, stressed_state loading.
    """
    p = DATA_DIR / name
    if not p.exists():
        print(f"[WARN] {name} not found in {DATA_DIR}")
        return None
    try:
        return json.loads(p.read_text())
    except Exception as e:
        print(f"[ERROR] failed to parse {name}: {e}")
        return None

def _to_datetime(x):
    """
    Coerce input to datetime (date-only).

    Args:
        x: str (ISO) or similar.

    Returns:
        datetime: Parsed or UTC now on failure.

    Purpose:
        Standardizes dates for horizon comparisons in flow bucketing.
    """
    try:
        return datetime.fromisoformat(str(x)[:10])
    except Exception:
        return datetime.utcnow()

def _flows_30d(state):
    """
    Compute inflows/outflows from state['cashflows'] (for cross-check).

    Args:
        state: Dict from state.json.

    Returns:
        tuple[float, float]: (inflows, outflows) in USD over 30-day horizon.

    Process:
        - Parses 'date'/'value_date' to datetime.
        - Buckets to [as_of, as_of+30d].
        - Signs by direction/amount: out/pay/debit/- → outflow (abs); else inflow (abs).
        - Mirrors state_builder bucketing for validation.

    Notes:
        - Assumes USD; FX applied upstream.
        - Handles missing dates (defaults to as_of).
    """
    """Compute inflows/outflows from state['cashflows'] (for cross-check)."""
    inflow = outflow = 0.0
    as_of = _to_datetime(state.get("as_of"))
    end = as_of + timedelta(days=30)
    for cf in state.get("cashflows", []):
        try:
            dt_raw = cf.get("date") or cf.get("value_date") or as_of
            dt = _to_datetime(dt_raw)
        except Exception:
            dt = as_of
        if not (as_of <= dt <= end):
            continue
        amt = float(cf.get("amount") or 0.0)
        dirraw = str(cf.get("direction") or "").lower()
        if dirraw in ("out","pay","debit","payout","-1","-") or amt < 0:
            outflow += abs(amt)
        else:
            inflow += abs(amt)
    return inflow, outflow

def _hqla_total(state):
    """
    Sum HQLA amounts from state['hqla'].

    Args:
        state: Dict from state.json.

    Returns:
        float: Total USD (raw, pre-haircut).

    Notes:
        - Uses 'amount_usd' or 'amount'; skips errors.
        - For LCR numerator; effective used in stressed.
    """
    hqla = state.get("hqla", []) or []
    total = 0.0
    for h in hqla:
        try:
            total += float(h.get("amount_usd") or h.get("amount") or 0.0)
        except Exception:
            pass
    return total

# ------------------------- Core logic -------------------------

def summarize_state(state, label="baseline"):
    """
    Print and return summary metrics using the same logic as state_builder.

    Args:
        state: Dict from state.json.
        label: Str for print header (e.g., 'baseline', 'stressed').

    Returns:
        dict: Metrics {'hqla', 'inflows', 'outflows', 'raw_net', 'lcr_effective', 'survival_effective'}.

    Process:
        - Recomputes flows/HQLA.
        - Applies clipping/fallback: net=max(0, raw_net); gross if raw_net<=0.
        - Prints formatted metrics and stored comparisons.
        - Audit: Lists _audit keys if present.

    Compliance:
        - Effective LCR: Net if outflows > inflows; gross conservative otherwise.
        - Flags None (zero denom) per Basel (undefined if no outflows).
    """
    """Print and return summary metrics using the same logic as state_builder."""
    hqla = _hqla_total(state)
    inflows, outflows = _flows_30d(state)
    raw_net = outflows - inflows
    net_clipped = max(0.0, raw_net)

    # Baseline computed metrics
    lcr_net = (hqla / net_clipped) if net_clipped > 0 else None
    lcr_gross = (hqla / outflows) if outflows > 0 else None
    surv_net = (30.0 * hqla / net_clipped) if net_clipped > 0 else None
    surv_gross = (30.0 * hqla / outflows) if outflows > 0 else None

    print(f"\n--- {label.upper()} STATE ---")
    print(f"HQLA total (USD): {hqla:,.2f}")
    print(f"Inflows 30d (USD): {inflows:,.2f}")
    print(f"Outflows 30d (USD): {outflows:,.2f}")
    print(f"Raw net_outflows (out-in): {raw_net:,.2f}")

    if raw_net <= 0:
        print("[INFO] Inflows exceed outflows → using conservative gross-outflow LCR.")
        lcr_effective = lcr_gross
        surv_effective = surv_gross
    else:
        lcr_effective = lcr_net
        surv_effective = surv_net

    print(f"LCR (effective): {lcr_effective:.6f}" if lcr_effective else "LCR (effective): None")
    print(f"Survival days (effective): {surv_effective:.2f}" if surv_effective else "Survival days: None")

    # Extract from state for comparison
    state_lcr = state.get("lcr_computed_net") or state.get("lcr_computed_gross")
    state_surv = state.get("survival_days_computed_net") or state.get("survival_days_computed_gross")
    print(f"Stored LCR in state: {state_lcr}")
    print(f"Stored Survival in state: {state_surv}")

    if "_audit" in state:
        print(f"Audit keys: {list(state['_audit'].keys())}")

    return {
        "hqla": hqla,
        "inflows": inflows,
        "outflows": outflows,
        "raw_net": raw_net,
        "lcr_effective": lcr_effective,
        "survival_effective": surv_effective,
    }

def extract_var_from_state(state):
    """
    Load VaR from state.profile_var.var_1d_99_usd.

    Args:
        state: Dict from state.json.

    Returns:
        float or None: 1d 99% VaR USD.

    Notes:
        - Prints value or 'None' message.
        - For market risk baseline; integrates with LCR for ALM view.
    """
    """Load VaR from state.profile_var.var_1d_99_usd."""
    profile_var = state.get("profile_var", {})
    var = profile_var.get("var_1d_99_usd")
    if var is None:
        print("Baseline VaR 1d 99% (USD): None (no profile_var in state)")
        return None
    print(f"Baseline VaR 1d 99% (USD): {var:,.2f}")
    return var

# ------------------------- Execution -------------------------

if __name__ == "__main__":
    """
    CLI Entry Point: Validate baseline (and stressed if present).

    Behavior:
        - Loads state.json, portfolio_view.json (required); stressed_state.json (optional).
        - Summarizes baseline metrics/VaR/outflows.
        - If stressed: Compares LCR (flags if stressed > baseline).
        - Exits 2 on missing baseline files.
        - Prints 'Validation complete.' on success.

    PoC Usage:
        - Run post-build: Ensures state coherence before stress/hedge phases.
        - Extend: To pytest for CI; or Streamlit for interactive metrics dashboard.
        - Warnings: No stressed → baseline-only; logical checks only on LCR (not VaR).
    """
    state = load_json("state.json")
    portfolio = load_json("portfolio_view.json")
    stressed = load_json("stressed_state.json")

    if not state or not portfolio:
        print("Missing baseline files; cannot validate.")
        raise SystemExit(2)

    base = summarize_state(state, "baseline")
    var = extract_var_from_state(state)  # Extract and print VaR

    # Print summary outflows (using stored in state for consistency)
    outflows_30d = state.get("outflows_30d_usd", base["outflows"])
    print(f"Baseline Outflows 30d (USD): {outflows_30d:,.2f}")

    if stressed:
        stress = summarize_state(stressed, "stressed")
        print("\n--- COMPARISON ---")
        b = base["lcr_effective"]
        s = stress["lcr_effective"]
        if b is None or s is None:
            print("[WARN] Cannot compare LCRs (one is None).")
        elif s > b:
            print(f"[FAIL] Stressed LCR {s:.6f} > Baseline {b:.6f} (impossible).")
        else:
            print(f"[OK] Stressed LCR {s:.6f} ≤ Baseline {b:.6f} (logical).")
    else:
        print("\nNo stressed_state.json found — baseline only.")

    print("\nValidation complete.")